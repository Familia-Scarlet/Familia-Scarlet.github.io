import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as r,c as a,a as h}from"./app-5a72580e.js";const d={},i=h('<h2 id="executor配置" tabindex="-1"><a class="header-anchor" href="#executor配置" aria-hidden="true">#</a> Executor配置</h2><h3 id="shuffle" tabindex="-1"><a class="header-anchor" href="#shuffle" aria-hidden="true">#</a> shuffle</h3><p>类似是计算结果的暂存区，shuffle service可以管理executor中各Task的输出文件，这样某个executor执行完后在Map-Reduce阶段可以把计算结果暂存到shuffle service中，然后释放自身资源。等全部同一级的executor执行完，下一级的executor可以从shuffle</p><p>服务中取出之前暂存的计算结果来进行下一级的计算。</p><h2 id="driver配置" tabindex="-1"><a class="header-anchor" href="#driver配置" aria-hidden="true">#</a> Driver配置</h2><p>主要配置内存，相关的有<code>spark.driver.memory</code>和<code>spark.driver.memoryOverhead</code></p><h2 id="hive-sql执行计划" tabindex="-1"><a class="header-anchor" href="#hive-sql执行计划" aria-hidden="true">#</a> Hive SQL执行计划</h2><h2 id="分组聚合优化" tabindex="-1"><a class="header-anchor" href="#分组聚合优化" aria-hidden="true">#</a> 分组聚合优化</h2><p>map-side聚合，将聚合提前到Map阶段进行，只有部分聚合，在最后的reduce再利用已经部分聚合的计算结果进行最终聚合。</p><h2 id="join优化" tabindex="-1"><a class="header-anchor" href="#join优化" aria-hidden="true">#</a> Join优化</h2>',10),c=[i];function o(s,t){return r(),a("div",null,c)}const u=e(d,[["render",o],["__file","Spark调优.html.vue"]]);export{u as default};
