import{_ as t}from"./plugin-vue_export-helper-c27b6911.js";import{r as l,o as p,c as r,a,b as n,d as s,e as i}from"./app-2a3f418e.js";const d="/assets/截图_20230323002839-6590a614.png",c="/assets/202205071832785-a2ff82eb.png",o="/assets/202205071832707-ac22febd.png",u={},h=i(`<h2 id="const" tabindex="-1"><a class="header-anchor" href="#const" aria-hidden="true">#</a> const</h2><p>const一般用在代码前面表示常量，只可读不可改，这里用在函数中表示常成员函数： 只读函数，只可读不可改数据成员的值。也就是时候const定义的函数里面的数据成员 的值不可改变</p><h2 id="重载单目运算符" tabindex="-1"><a class="header-anchor" href="#重载单目运算符" aria-hidden="true">#</a> 重载单目运算符++</h2><p>前置++的效率好，因为没有临时对象的产生</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>A&amp; operator++()//++i 前置++实现
{
    ++x;	//先自增
    ++y;
    return *this;	//后引用
}
A operator++(int)	//i++ 后置++实现
{
    //int参数没有任何意义，只是为了区分是前置还是后置形式
    A a = *this;	//保存对象引用
    ++(*this);	//自增，调用前面实现的前置++
    return a;	//返回先前保存的对象
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="内存模型" tabindex="-1"><a class="header-anchor" href="#内存模型" aria-hidden="true">#</a> 内存模型</h2><p>C分为四个区：堆，栈，静态全局变量区，常量区</p><p>C++内存分为5个区域（堆栈全常代 ）：</p><p>（低地址端）.text---&gt;.data ---&gt;.bss---&gt;heap--&gt;unused&lt;---stack（高地址端）</p><ol><li>堆 heap ：<br> 由new分配的内存块，其释放编译器不去管，由我们程序自己控制（一个new对应一个delete）。如果程序员没有释放掉，在程序结束时OS会自动回收。涉及的问题：“缓冲区溢出”、“内存泄露”</li><li>栈 stack ：<br> 是那些编译器在需要时分配，在不需要时自动清除的存储区。存放局部变量、函数参数。<br> 存放在栈中的数据只在当前函数及下一层函数中有效，一旦函数返回了，这些数据也就自动释放了。</li><li>全局/静态存储区 （.bss段和.data段） ：<br> 全局和静态变量被分配到同一块内存中。在C语言中，未初始化的放在.bss段中，初始化的放在.data段中；在C++里则不区分了。</li><li>常量存储区 （.rodata段） ：<br> 存放常量，不允许修改（通过非正当手段也可以修改）</li><li>代码区 （.text段） ：<br> 存放代码（如函数），不允许修改（类似常量存储区），但可以执行（不同于常量存储区）</li></ol><figure><img src="`+d+`" alt="截图_20230323002839" tabindex="0" loading="lazy"><figcaption>截图_20230323002839</figcaption></figure><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>//main.cpp
int a = 0;        //a在全局已初始化数据区
char *p1;        //p1在BSS区（未初始化全局变量）
main()
{
int b;        //b在栈区
char s[] = &quot;abc&quot;;  //s为数组变量，存储在栈区，
//&quot;abc&quot;为字符串常量，存储在已初始化数据区
char *p1，*p2;    //p1、p2在栈区
char *p3 = &quot;123456&quot;;  //123456\\0在已初始化数据区，p3在栈区
static int c =0；    //C为全局（静态）数据，存在于已初始化数据区
//另外，静态数据会自动初始化
p1 = (char *)malloc(10);//分配得来的10个字节的区域在堆区
p2 = (char *)malloc(20);//分配得来的20个字节的区域在堆区
free(p1);
free(p2);
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="在main执行之前和之后执行的代码可能是什么" tabindex="-1"><a class="header-anchor" href="#在main执行之前和之后执行的代码可能是什么" aria-hidden="true">#</a> 在main执行之前和之后执行的代码可能是什么</h2><p><strong>main函数执行之前</strong>，主要就是初始化系统相关资源：</p><ul><li>设置栈指针，即初始化stack区</li><li>初始化静态<code>static</code>变量和<code>global</code>全局变量，即<code>.data</code>段的内容</li><li>将未初始化部分的全局变量赋初值：数值型<code>short</code>，<code>int</code>，<code>long</code>等为<code>0</code>，<code>bool</code>为<code>FALSE</code>，指针为<code>NULL</code>等等，即<code>.bss</code>段的内容</li><li>全局对象初始化，在<code>main</code>之前调用构造函数，这是可能会执行前的一些代码</li><li>将main函数的参数<code>argc</code>，<code>argv</code>等传递给<code>main</code>函数，然后才真正运行<code>main</code>函数</li><li><code>__attribute__((constructor))</code>修饰的函数会在main之前执行</li></ul><p><strong>main函数执行之后</strong>：</p><ul><li>全局对象的析构函数会在main函数之后执行；</li><li>可以用 <strong><code>atexit()函数</code></strong> 注册一个函数，它会在main 之后执行;</li><li><code>__attribute__((destructor))</code>修饰的函数也会在main之后执行</li></ul><h2 id="结构体内存对齐问题" tabindex="-1"><a class="header-anchor" href="#结构体内存对齐问题" aria-hidden="true">#</a> 结构体内存对齐问题</h2><ul><li>结构体内成员按照声明顺序存储，第一个成员地址和整个结构体地址相同。</li><li>未特殊说明时，按结构体中size最大的成员对齐（若有double成员，按8字节对齐。）</li></ul>`,19),v={href:"https://zh.cppreference.com/w/cpp/language/alignas",target:"_blank",rel:"noopener noreferrer"},m={href:"https://zh.cppreference.com/w/cpp/language/alignof",target:"_blank",rel:"noopener noreferrer"},b=i(`<p>其中<code>alignof</code>可以计算出类型的对齐方式，<code>alignas</code>可以指定结构体的对齐方式，注意如果指定的对齐长度小于自然对齐的长度，<code>alignas</code>是无法生效的。</p><h2 id="指针和引用的区别" tabindex="-1"><a class="header-anchor" href="#指针和引用的区别" aria-hidden="true">#</a> 指针和引用的区别</h2><ul><li>指针是一个变量，存储的是一个地址，引用跟原来的变量实质上是同一个东西，是原变量的别名</li><li>指针可以有多级，引用只有一级</li><li>指针可以为空，引用不能为NULL且在定义时必须初始化</li><li>指针在初始化后可以改变指向，而引用在初始化之后不可再改变</li><li>sizeof指针得到的是本指针的大小，sizeof引用得到的是引用所指向变量的大小</li><li>当把指针作为参数进行传递时，也是将实参的一个拷贝传递给形参，两者指向的地址相同，但不是同一个变量，在函数中改变这个变量的指向不影响实参，而引用却可以。</li><li>引用本质是一个指针，同样会占4字节内存；指针是具体变量，需要占用存储空间（，具体情况还要具体分析）。</li><li>引用在声明时必须初始化为另一变量，一旦出现必须为typename refname &amp;varname形式；指针声明和定义可以分开，可以先只声明指针变量而不初始化，等用到时再指向具体变量。</li><li>引用一旦初始化之后就不可以再改变（变量可以被引用为多次，但引用只能作为一个变量引用）；指针变量可以重新指向别的变量。</li><li>不存在指向空值的引用，必须有具体实体；但是存在指向空值的指针。</li></ul><p>最大的区别，引用传参能在函数中被改变，指针传参传的是被拷贝后的实参</p><h2 id="在传递函数参数时-什么时候该使用指针-什么时候该使用引用呢" tabindex="-1"><a class="header-anchor" href="#在传递函数参数时-什么时候该使用指针-什么时候该使用引用呢" aria-hidden="true">#</a> 在传递函数参数时，什么时候该使用指针，什么时候该使用引用呢？</h2><ul><li>需要返回函数内局部变量的内存的时候用指针。使用指针传参需要开辟内存，用完要记得释放指针，不然会内存泄漏。而返回局部变量的引用是没有意义的，因为局部变量超出有效域后会被析构，这么一来引用也没有了意义。</li><li>对栈空间大小比较敏感（比如递归）的时候使用引用。使用引用传递不需要创建临时变量，开销要更小</li><li>类对象作为参数传递的时候使用引用，这是C++类对象传递的标准方式</li></ul><h2 id="堆和栈的区别" tabindex="-1"><a class="header-anchor" href="#堆和栈的区别" aria-hidden="true">#</a> 堆和栈的区别</h2><table><thead><tr><th style="text-align:left;"></th><th>堆</th><th>栈</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>管理方式</strong></td><td>堆中资源由程序员控制（容易产生memory leak）</td><td>栈资源由编译器自动管理，无需手工控制</td></tr><tr><td style="text-align:left;"><strong>内存管理机制</strong></td><td>系统有一个记录空闲内存地址的链表，当系统收到程序申请时，遍历该链表，寻找第一个空间大于申请空间的堆结点，删 除空闲结点链表中的该结点，并将该结点空间分配给程序（大多数系统会在这块内存空间首地址记录本次分配的大小，这样delete才能正确释放本内存空间，另外系统会将多余的部分重新放入空闲链表中）</td><td>只要栈的剩余空间大于所申请空间，系统为程序提供内存，否则报异常提示栈溢出。（这一块理解一下链表和队列的区别，不连续空间和连续空间的区别，应该就比较好理解这两种机制的区别了）</td></tr><tr><td style="text-align:left;"><strong>空间大小</strong></td><td>堆是不连续的内存区域（因为系统是用链表来存储空闲内存地址，自然不是连续的），堆大小受限于计算机系统中有效的虚拟内存（32bit 系统理论上是4G），所以堆的空间比较灵活，比较大</td><td>栈是一块连续的内存区域，大小是操作系统预定好的，windows下栈大小是2M（也有是1M，在 编译时确定，VC中可设置）</td></tr><tr><td style="text-align:left;"><strong>碎片问题</strong></td><td>对于堆，频繁的new/delete会造成大量碎片，使程序效率降低</td><td>对于栈，它是有点类似于数据结构上的一个先进后出的栈，进出一一对应，不会产生碎片。（看到这里我突然明白了为什么面试官在问我堆和栈的区别之前先问了我栈和队列的区别）</td></tr><tr><td style="text-align:left;"><strong>生长方向</strong></td><td>堆向上，向高地址方向增长。</td><td>栈向下，向低地址方向增长。</td></tr><tr><td style="text-align:left;"><strong>分配方式</strong></td><td>堆都是动态分配（没有静态分配的堆）</td><td>栈有静态分配和动态分配，静态分配由编译器完成（如局部变量分配），动态分配由alloca函数分配，但栈的动态分配的资源由编译器进行释放，无需程序员实现。</td></tr><tr><td style="text-align:left;"><strong>分配效率</strong></td><td>堆由C/C++函数库提供，机制很复杂。所以堆的效率比栈低很多。</td><td>栈是其系统提供的数据结构，计算机在底层对栈提供支持，分配专门 寄存器存放栈地址，栈操作有专门指令。</td></tr></tbody></table><h2 id="区别以下指针类型" tabindex="-1"><a class="header-anchor" href="#区别以下指针类型" aria-hidden="true">#</a> 区别以下指针类型</h2><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>int *p[10]           //指针的数组
int (*p)[10]		  //数组的指针
int *p(int)          //函数声明，函数名是p，参数是int类型的，返回值是int *类型的。
int (*p)(int)        //函数指针，强调是指针，该指针指向的函数具有int类型参数，并且返回值是int类型的
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="new-delete-与-malloc-free的异同" tabindex="-1"><a class="header-anchor" href="#new-delete-与-malloc-free的异同" aria-hidden="true">#</a> new / delete 与 malloc / free的异同</h2><p><strong>相同点</strong></p><ul><li>都可用于内存的动态申请和释放</li></ul><p><strong>不同点</strong></p><ul><li>前者是C++运算符，后者是C/C++语言标准库函数</li><li>new自动计算要分配的空间大小，malloc需要手工计算</li><li>new是类型安全的，malloc不是。例如：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">float</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//编译错误</span>
<span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//编译无错误</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>new调用名为<strong>operator new</strong>的标准库函数分配足够空间并调用相关对象的构造函数，delete对指针所指对象运行适当的析构函数；然后通过调用名为<strong>operator delete</strong>的标准库函数释放该对象所用内存。后者均没有相关调用</li><li>后者需要库文件支持，前者不用</li><li>new是封装了malloc，直接free不会报错，但是这只是释放内存，而不会析构对象</li></ul><h2 id="new和delete是如何实现的" tabindex="-1"><a class="header-anchor" href="#new和delete是如何实现的" aria-hidden="true">#</a> new和delete是如何实现的</h2><ul><li>new的实现过程是：首先调用名为<strong>operator new</strong>的标准库函数，分配足够大的原始为类型化的内存，以保存指定类型的一个对象；接下来运行该类型的一个构造函数，用指定初始化构造对象；最后返回指向新分配并构造后的的对象的指针</li><li>delete的实现过程：对指针指向的对象运行适当的析构函数；然后通过调用名为<strong>operator delete</strong>的标准库函数释放该对象所用内存</li></ul><h2 id="malloc和new的区别" tabindex="-1"><a class="header-anchor" href="#malloc和new的区别" aria-hidden="true">#</a> malloc和new的区别</h2><ul><li>malloc和free是标准库函数，支持覆盖；new和delete是运算符，支持重载。</li><li>malloc仅仅分配内存空间，free仅仅回收空间，不具备调用构造函数和析构函数功能，用malloc分配空间存储类的对象存在风险；new和delete除了分配回收功能外，还会调用构造函数和析构函数。</li><li>malloc和free返回的是void类型指针（必须进行类型转换），new和delete返回的是具体类型指针。</li></ul><h2 id="既然有了malloc-free-c-中为什么还需要new-delete呢-直接用malloc-free不好吗" tabindex="-1"><a class="header-anchor" href="#既然有了malloc-free-c-中为什么还需要new-delete呢-直接用malloc-free不好吗" aria-hidden="true">#</a> 既然有了malloc/free，C++中为什么还需要new/delete呢？直接用malloc/free不好吗？</h2><ul><li>malloc/free和new/delete都是用来申请内存和回收内存的。</li><li>在对非基本数据类型的对象使用的时候，对象创建的时候还需要执行构造函数，销毁的时候要执行析构函数，是C++的运算符。而malloc/free是库函数，是已经编译的代码，已经编译好的代码，如果覆盖malloc/free进行重写，这样就会违背了标准，所以不能把构造函数和析构函数的功能强加给malloc/free，所以new/delete是必不可少的。</li></ul><h2 id="被free回收的内存是立即返还给操作系统吗" tabindex="-1"><a class="header-anchor" href="#被free回收的内存是立即返还给操作系统吗" aria-hidden="true">#</a> 被free回收的内存是立即返还给操作系统吗？</h2><p>不是的，被free回收的内存会首先被ptmalloc使用双链表保存起来，当用户下一次申请内存的时候，会尝试从这些内存中寻找合适的返回。这样就避免了频繁的系统调用，占用过多的系统资源。同时ptmalloc也会尝试对小块内存进行合并，避免过多的内存碎片。</p><h2 id="宏定义和函数有何区别" tabindex="-1"><a class="header-anchor" href="#宏定义和函数有何区别" aria-hidden="true">#</a> 宏定义和函数有何区别？</h2><ul><li>宏在预处理阶段完成替换，之后被替换的文本参与编译，相当于直接插入了代码，运行时不存在函数调用，执行起来更快，类似内联函数；函数调用在运行时需要跳转到具体调用函数。</li><li>宏定义属于在结构中插入代码，没有返回值；函数调用具有返回值。</li><li>宏定义参数没有类型，不进行类型检查；函数参数具有类型，需要检查类型。</li><li>宏定义不要在最后加分号。</li></ul><h2 id="宏定义和typedef区别" tabindex="-1"><a class="header-anchor" href="#宏定义和typedef区别" aria-hidden="true">#</a> 宏定义和typedef区别？</h2><ul><li>宏主要用于定义常量及书写复杂的内容；typedef主要用于定义类型别名。</li><li>宏替换发生在编译阶段之前，属于文本插入替换；typedef是编译的一部分。</li><li>宏不检查类型；typedef会检查数据类型。</li><li>宏不是语句，不在在最后加分号；typedef是语句，要加分号标识结束。</li><li>注意对指针的操作，typedef char * p_char和#define p_char char *区别巨大。</li></ul><h2 id="变量声明和定义区别" tabindex="-1"><a class="header-anchor" href="#变量声明和定义区别" aria-hidden="true">#</a> 变量声明和定义区别</h2><ul><li>声明仅仅是把变量的声明的位置及类型提供给编译器，并不分配内存空间；定义要在定义的地方为其分配存储空间。</li><li>相同变量可以在多处声明（外部变量extern），但只能在一处定义</li></ul><h2 id="strlen和sizeof区别" tabindex="-1"><a class="header-anchor" href="#strlen和sizeof区别" aria-hidden="true">#</a> strlen和sizeof区别？</h2><ul><li>sizeof是<mark>运算符</mark>，并<mark>不是函数</mark>，结果在编译时得到而非运行中获得；strlen是<mark>字符</mark>处理的<mark>库函数</mark>。</li><li>sizeof参数可以是任何数据的类型或者数据（sizeof参数不退化）；strlen的参数只能是字符指针且结尾是&#39;\\0&#39;的字符串。</li><li>因为sizeof值在编译时确定，所以不能用来得到动态分配（运行时分配）存储空间的大小。</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>  <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token keyword">const</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      
      <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> str <span class="token operator">=</span> <span class="token string">&quot;name&quot;</span><span class="token punctuation">;</span>

      <span class="token keyword">sizeof</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 取的是指针str的长度，是8</span>
      <span class="token function">strlen</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 取的是这个字符串的长度，不包含结尾的 \\0。大小是4</span>
      <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="一个指针占多少字节" tabindex="-1"><a class="header-anchor" href="#一个指针占多少字节" aria-hidden="true">#</a> 一个指针占多少字节？</h2><p>在前面有提到sizeof（str）的值为8，是在64位的编译环境下的，指针的占用大小为8字节；</p><p>而在32位环境下，指针占用大小为4字节。</p><p>一个指针占内存的大小跟<mark>编译环境</mark>有关，有32位编译环境和64位编译环境，而与机器的位数无关，机器位数只是提供编译环境的支持。</p><h2 id="指针常量和常量指针" tabindex="-1"><a class="header-anchor" href="#指针常量和常量指针" aria-hidden="true">#</a> 指针常量和常量指针</h2><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>int a = 3;
int b = 1;
int c = 2;
int const *p1 = &amp;b;  //const 在前，定义为常量指针
int* const p2 = &amp;c;  //*在前，定义为指针常量 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol><li>二者的区别在于const和*的位置不同，const可以放在int前也可以在int后面，关键是const和*的相对位置。</li><li>const表示常量，*表示指针。const在前，<em>在后的是常量指针。</em>*在前，const在后的是指针常量。</li><li>常量指针的const在*p前，表示*p是只读的，即指针p指向的内容是只读的。但是指针本身并不是只读的，所以可能修改指针本身。</li><li>指针常量的*在const前，表示p是只读的，即指针变量本身是只读。但是指针所指向的内容不是只读的，可以修改。</li></ol><h2 id="c-的构造函数" tabindex="-1"><a class="header-anchor" href="#c-的构造函数" aria-hidden="true">#</a> C++的构造函数</h2><ul><li><p>默认构造函数</p></li><li><p>初始化构造函数</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>Student(int a, int n):age(a), num(n){};
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p>拷贝构造函数</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>Object a,b;     //默认构造函数
a = b;          //赋值语句
Object c = a;   //拷贝构造函数
Object d(c);    //拷贝构造函数
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="什么情况下会调用拷贝构造函数" tabindex="-1"><a class="header-anchor" href="#什么情况下会调用拷贝构造函数" aria-hidden="true">#</a> 什么情况下会调用拷贝构造函数</h4><ul><li>用类的一个实例化对象去初始化另一个对象的时候</li><li>函数的参数是类的对象时（非引用传递）</li><li>函数的返回值是函数体内局部对象的类的对象时 ,此时虽然发生（Named return Value优化）NRV优化，但是由于返回方式是值传递，所以会在返回值的地方调用拷贝构造函数</li></ul><p><strong>另：第三种情况在Linux g++ 下则不会发生拷贝构造函数，不仅如此即使返回局部对象的引用，依然不会发生拷贝构造函数</strong></p><p><strong>总结就是：即使发生NRV优化的情况下，Linux+ g++的环境是不管值返回方式还是引用方式返回的方式都不会发生拷贝构造函数，而Windows + VS2019在值返回的情况下发生拷贝构造函数，引用返回方式则不发生拷贝构造函数</strong>。</p><p>在c++编译器发生NRV优化，如果是引用返回的形式则不会调用拷贝构造函数，如果是值传递的方式依然会发生拷贝构造函数。</p></li><li><p>转换构造函数</p><p>转换构造函数分为两种情况，一种是显示转换，一种是隐式转换,隐式转换是自动的，如果想关闭隐式转换可以加关键字explicit</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>class string	//C++的string类就有一个将char*类型转换成string类型的转换构造函数
{
    //转换构造函数
    public:
        string(char *);//形参是其他类型变量，且只有一个形参
};
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>string str(&quot;233&quot;);           // 常规的写法。
string str = string(&quot;233&quot;);  // 显式转换。
string str = &quot;233&quot;;          // 隐式转换。
string str;                  // 创建对象。
str = 8;                     // 隐式转换，用CGirl(8)创建临时对象，再赋值给g。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>移动构造函数</p><p>对于程序执行过程中产生的临时对象，往往只用于传递数据（没有其它的用处），并且会很快会被销毁。因此在使用<strong>临时对象初始化新对象时</strong>，我们可以将其包含的指针成员指向的内存资源直接移给新对象所有，无需再新拷贝一份，这大大提高了初始化的执行效率。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>class A {
public:
	int x;
	A(int x) : x(x)
	{
		cout &lt;&lt; &quot;Constructor&quot; &lt;&lt; endl;
	}
	A(A&amp; a) : x(a.x)
	{
		cout &lt;&lt; &quot;Copy Constructor&quot; &lt;&lt; endl;
	}
	A&amp; operator=(A&amp; a)
	{
		x = a.x;
		cout &lt;&lt; &quot;Copy Assignment operator&quot; &lt;&lt; endl;
		return *this;
	}
	A(A&amp;&amp; a) : x(a.x)
	{
		cout &lt;&lt; &quot;Move Constructor&quot; &lt;&lt; endl;
	}
	A&amp; operator=(A&amp;&amp; a)
	{
		x = a.x;
		cout &lt;&lt; &quot;Move Assignment operator&quot; &lt;&lt; endl;
		return *this;
	}
};
 
 
int main()
{
	A a(1);
	A b = a;
	A c(a);
	b = a;
	A e = move(a);
 
	system(&quot;pause&quot;);
	return 0;
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>Constructor
Copy Constructor
Copy Constructor
Copy Assignment <span class="token keyword">operator</span>
Move Constructor
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>A a(1)，调用构造函数。</p><p>A b = a，创建新对象b，使用a初始化b，因此调用拷贝构造函数。</p><p>A c(a)，创建新对象c，使用a初始化c，因此调用拷贝构造函数。</p><p>b = a，使用a的值更新对象b，因为不需要创建新对象，所以调用拷贝赋值运算符。</p><p>A e = move(a)，创建新对象e，使用a的值初始化e，但调用move(a)将左值a转化为右值，所以调用移动构造函数。</p></li><li><p>委托构造函数</p><p>委托构造函数使用类的其他构造函数执行初始化过程。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>//初始化构造函数
Student(int a, int n):age(a), num(n){};
//委托构造函数
Student(int role){
	Student(1,2);//调用了初始化构造函数
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h2 id="左值和右值的理解" tabindex="-1"><a class="header-anchor" href="#左值和右值的理解" aria-hidden="true">#</a> 左值和右值的理解</h2><h3 id="_1、左值和右值的概念" tabindex="-1"><a class="header-anchor" href="#_1、左值和右值的概念" aria-hidden="true">#</a> 1、左值和右值的概念</h3><p>C++中左值（lvalue）和右值（rvalue）是比较基础的概念，虽然平常几乎用不到，但C++11之后变得十分重要，它是理解 move/forward 等新语义的基础。</p><p>左值与右值这两个概念是从 C 中传承而来的，左值指既能够出现在等号左边，也能出现在等号右边的变量；右值则是只能出现在等号右边的变量。</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> a<span class="token punctuation">;</span> <span class="token comment">// a 为左值</span>
a <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment">// 3 为右值</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>左值是可寻址的变量，有持久性；</li><li>右值一般是不可寻址的常量，或在表达式求值过程中创建的无名临时对象，短暂性的。</li></ul><p>左值和右值主要的区别之一是左值可以被修改，而右值不能。</p><p>何为左值？能用取址符号 &amp; 取出地址的皆为左值，剩下的都是右值。</p><h3 id="_2、左值引用和右值引用" tabindex="-1"><a class="header-anchor" href="#_2、左值引用和右值引用" aria-hidden="true">#</a> 2、左值引用和右值引用</h3><ul><li>左值引用：引用一个对象；</li><li>右值引用：就是必须绑定到右值的引用，C++11中右值引用可以实现“移动语义”，通过 &amp;&amp; 获得右值引用。</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span> <span class="token comment">// x是左值，6是右值</span>
<span class="token keyword">int</span> <span class="token operator">&amp;</span>y <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token comment">// 左值引用，y引用x</span>

<span class="token keyword">int</span> <span class="token operator">&amp;</span>z1 <span class="token operator">=</span> x <span class="token operator">*</span> <span class="token number">6</span><span class="token punctuation">;</span> <span class="token comment">// 错误，x*6是一个右值</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>z2 <span class="token operator">=</span>  x <span class="token operator">*</span> <span class="token number">6</span><span class="token punctuation">;</span> <span class="token comment">// 正确，可以将一个const引用绑定到一个右值</span>

<span class="token keyword">int</span> <span class="token operator">&amp;&amp;</span>z3 <span class="token operator">=</span> x <span class="token operator">*</span> <span class="token number">6</span><span class="token punctuation">;</span> <span class="token comment">// 正确，右值引用</span>
<span class="token keyword">int</span> <span class="token operator">&amp;&amp;</span>z4 <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token comment">// 错误，x是一个左值</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>右值引用和相关的移动语义是C++11标准中引入的最强大的特性之一，通过==std::move()==可以避免无谓的复制，提高程序性能。</p><h2 id="拷贝构造和移动构造" tabindex="-1"><a class="header-anchor" href="#拷贝构造和移动构造" aria-hidden="true">#</a> 拷贝构造和移动构造</h2><p>移动构造的目的是将成员变量所占有的内存移交出去，而拷贝构造也是可以实现这点的，但是一个正常的拷贝构造不应该是浅拷贝，所以就引入了移动构造，因此要说拷贝构造和移动构造的区别，这样这么理解拷贝构造实际是深拷贝构造而移动构造实际是浅拷贝构造。</p><h2 id="对齐规则" tabindex="-1"><a class="header-anchor" href="#对齐规则" aria-hidden="true">#</a> 对齐规则</h2><p>结构体和类都要进行对齐，对齐是为了存取数据时候能够不让一个基本类型跨两个内存块。</p><p>进行对齐时候要根据<mark>对其值</mark>来对齐。</p><ol><li>基本类型的对齐值就是其sizeof值;</li><li>结构体或类的对齐值是其成员的最大对齐值;</li><li>编译器可以设置一个最大对齐值，怎么类型的实际对齐值是该类型的对齐值与默认对齐值取最小值得来。</li></ol><h2 id="虚继承与虚函数" tabindex="-1"><a class="header-anchor" href="#虚继承与虚函数" aria-hidden="true">#</a> 虚继承与虚函数</h2><p>虚函数继承和虚继承是完全不同的两个概念。</p><ul><li><p>虚函数是解决多态性的，当用基类指针指向派生类对象的时候，基类指针调用虚函数的时候会自动调用派生类的虚函数，这就是多态性，也叫动态编联。</p></li><li><p>虚继承就是为了节约内存，他是多重继承中的特有的概念。适用于菱形继承形式。</p></li></ul><h3 id="调用基类的虚函数" tabindex="-1"><a class="header-anchor" href="#调用基类的虚函数" aria-hidden="true">#</a> 调用基类的虚函数</h3><p>使用作用域解析运算符（::）调用基类被重写的虚函数是通过告诉编译器要访问基类中的成员来实现的，底层实现上则是通过在派生类对象的虚函数表中查找基类版本的虚函数并进行调用来实现的。这时候其实已经是静态绑定了，而非多态中的运行时动态绑定，编译器就能确定。</p><h3 id="虚函数" tabindex="-1"><a class="header-anchor" href="#虚函数" aria-hidden="true">#</a> 虚函数</h3><p>虚函数的目的就是为了被重写，重写后就能实现多态了。</p><p>前面提到过，一个指针的大小是8字节，当一个类有声明虚函数的时候，这个类的结构中就会有一个虚指针，这个虚指针就是8B的，这就是为什么一个声明了虚函数的类只有int类型，但大小有16B，就是因为虚指针改变的对其值，使得这个类以8B为对齐值。</p><p><mark>虚函数继承</mark>时，虚指针只会存在基类中，所以派生类是没有虚指针的，即使派生类也声明了<mark>虚函数</mark>，甚至是虚继承的派生类，这样也没有第二个虚指针。也就是说有多少个直接基类，就有多少个虚指针。</p><p>总结下来就是，基类有虚函数那么虚指针就在虚函数中，如果基类没有虚函数而派生类有虚函数，那么虚指针在派生类中。</p><p>当不存在虚继承，且基类和派生类都声明了虚函数的时候，虚函数的内存模型如下，地址从上往下升高。</p><p>|vfptr|</p><p>|基类成员|</p><p>|派生类成员|</p><p>当不存在虚继承，且基类和派生类都声明了虚函数，且有两个基类的时候，虚函数的内存模型如下，地址从上往下升高。</p><p>|第一个基类vfptr|</p><p>|第一个基类成员|</p><p>|第二个基类vfptr|</p><p>|第二个基类成员|</p><p>|派生类成员|</p><p>当不存在虚继承，且基类和派生类都声明了虚函数，且有多级继承的时候，虚函数的内存模型如下，地址从上往下升高。</p><p>|爷爷类vfptr|</p><p>|爷爷类成员|</p><p>|爸爸类成员|</p><p>|儿子类成员|</p><h3 id="虚继承" tabindex="-1"><a class="header-anchor" href="#虚继承" aria-hidden="true">#</a> 虚继承</h3><p>虚继承的目的是解决类似菱形继承重复包含基类成员的问题。</p><p>虚继承实现的核心也是虚基类指针（vbptr），因为在虚基类指针指向的虚基类表中存放着虚基类的偏移量，通过派生类的地址加上这个偏移量就能找到这个虚基类。要注意区分vfptr和vbptr，虚表指针（vfptr）存放在基类中，虚基类指针存放在派生类中（vbptr）。</p><p>相比普通的继承，虚继承方式中，基类在高地址处，派生类在低地址处。</p><p><mark>注意</mark>，虚继承和编译器有关，比如MSVC的有vbptr和vfptr，而mingw的vbptr和vfptr是合并的==（存疑，但先这么理解）==，这里的举例全都是以MSVC为准。</p><p>总结下来就是，虚基类声明了虚函数，那么虚基类中就有vfptr，派生类中必定有vbptr，且如果派生类声明了虚函数，那么派生类中也会有vfptr。如果是A被B虚继承，B被C继承，A和C有声明虚函数而B没有，那么A和C都会有vfptr。也就是说，将虚继承部分切割掉后，剩下的部分和虚函数时候的情况一样。</p><p>当存在虚继承，且<mark>基类和派生类都没有声明虚函数</mark>的时候，虚继承的内存模型如下，地址从上往下升高。</p><p>|vbptr|</p><p>|派生类成员|</p><p>|基类成员|</p><p>当存在虚继承，且<mark>基类声明虚函数而派生类没有声明虚函数</mark>的时候，虚继承的内存模型如下，地址从上往下升高。</p><p>|派生类vbptr|</p><p>|派生类成员|</p><p>|基类vfptr|</p><p>|基类成员|</p><p>当存在虚继承，且<mark>基类没有声明虚函数而派生类声明虚函数</mark>的时候，虚继承的内存模型如下，地址从上往下升高。</p><p>|派生类vfptr|</p><p>|派生类vbptr|</p><p>|派生类成员|</p><p>|基类成员|</p><p>当存在虚继承，且<mark>基类和派生类都声明虚函数</mark>的时候，虚继承的内存模型如下，地址从上往下升高。</p><p>|派生类vfptr|</p><p>|派生类vbptr|</p><p>|派生类成员|</p><p>|基类vfptr|</p><p>|基类成员|</p><p>当存在虚继承，且<mark>基类和派生类都声明了虚函数，且有多级继承</mark>的时候，虚函数的内存模型如下，地址从上往下升高。</p><p>|儿子类vfptr|</p><p>|儿子类vbptr|</p><p>|儿子类成员|</p><p>|爷爷类vfptr|</p><p>|爷爷类成员|</p><p>|爸爸类vfptr|</p><p>|爸爸类vbptr|</p><p>|爸爸类成员|</p><p>当存在虚继承，且<mark>基类声明了虚函数，菱形继承</mark>，虚函数的内存模型如下，地址从上往下升高。</p><p>|爸爸类vbptr|</p><p>|爸爸类成员|</p><p>|叔叔类vbptr|</p><p>|叔叔类成员|</p><p>|派生类成员|</p><p>|爷爷类vfptr|</p><p>|爷爷类成员|</p><h2 id="区分虚指针、虚表、虚函数指针、虚函数、虚基类表指针、虚基类表、虚基类指针、虚基类" tabindex="-1"><a class="header-anchor" href="#区分虚指针、虚表、虚函数指针、虚函数、虚基类表指针、虚基类表、虚基类指针、虚基类" aria-hidden="true">#</a> 区分虚指针、虚表、虚函数指针、虚函数、虚基类表指针、虚基类表、虚基类指针、虚基类</h2><h3 id="虚函数表与虚函数表指针" tabindex="-1"><a class="header-anchor" href="#虚函数表与虚函数表指针" aria-hidden="true">#</a> 虚函数表与虚函数表指针</h3><h4 id="虚函数表指针" tabindex="-1"><a class="header-anchor" href="#虚函数表指针" aria-hidden="true">#</a> 虚函数表指针：</h4><p>虚函数表指针又称为：虚表指针。虚表指针指向的是一张虚函数表。</p><h4 id="虚函数表" tabindex="-1"><a class="header-anchor" href="#虚函数表" aria-hidden="true">#</a> 虚函数表：</h4><p>虚函数表又称为：虚表。虚表中存放的是虚函数指针，因此虚表可以看成是一个函数指针数组。虚表在编译阶段生成。</p><h4 id="虚表指针在哪里" tabindex="-1"><a class="header-anchor" href="#虚表指针在哪里" aria-hidden="true">#</a> 虚表指针在哪里？</h4><p>虚表指针存在于有虚函数的类对象中；</p><h4 id="虚表在哪里" tabindex="-1"><a class="header-anchor" href="#虚表在哪里" aria-hidden="true">#</a> 虚表在哪里？</h4><p>虚表存在于.rodata段，常量区；</p><h4 id="虚函数在哪里" tabindex="-1"><a class="header-anchor" href="#虚函数在哪里" aria-hidden="true">#</a> 虚函数在哪里？</h4><p>虚函数保存在.text段，代码区；</p><h4 id="基类虚表的构建规则" tabindex="-1"><a class="header-anchor" href="#基类虚表的构建规则" aria-hidden="true">#</a> 基类虚表的构建规则：</h4><p>按照虚函数在基类中的声明顺序存放在虚函数表中。</p><h4 id="派生类虚表的构建规则" tabindex="-1"><a class="header-anchor" href="#派生类虚表的构建规则" aria-hidden="true">#</a> 派生类虚表的构建规则：</h4><ol><li>将基类虚表中的内容拷贝一份保存到派生类的虚表中；</li><li>如果派生类中重写了基类中的虚函数，那么在派生类的虚表中，派生类重写后的虚函数地址将替换（覆盖）掉继承下来的虚函数地址；</li><li>派生类自己增加的虚函数，按照在派生类中的声明顺序存放在派生类的虚表的后边；（注意:在VS下监视窗口查看时，没有显示）；</li></ol><p>即派生类虚表中保存的是继承的未被重写的虚函数，派生类重写之后的虚函数以及派生类自己的虚函数的地址；</p><h4 id="虚函数表作用" tabindex="-1"><a class="header-anchor" href="#虚函数表作用" aria-hidden="true">#</a> 虚函数表作用：</h4><p>用来解决保存虚函数的问题以及实现多态的基础；</p><h3 id="虚基类表和虚基类表指针" tabindex="-1"><a class="header-anchor" href="#虚基类表和虚基类表指针" aria-hidden="true">#</a> 虚基类表和虚基类表指针</h3><h4 id="虚基类表指针" tabindex="-1"><a class="header-anchor" href="#虚基类表指针" aria-hidden="true">#</a> 虚基类表指针：</h4><p>虚基类表指针又称为：虚基表指针；是虚继承下来的派生类中的成员；指向一张虚基表；</p><h4 id="虚基类类表" tabindex="-1"><a class="header-anchor" href="#虚基类类表" aria-hidden="true">#</a> 虚基类类表：</h4><p>虚基类表又称为虚基表，虚基表中记录了虚基类与派生类的偏移地址；通过偏移地址，这样就找到了虚基类成员；<br> 虚基表中存放两个成员：一个是0(可以认为是<mark>虚基类与自己的偏移量</mark>)，另一个是<mark>虚基类与派生类的偏移量</mark>;</p><h4 id="虚基表指针在哪里" tabindex="-1"><a class="header-anchor" href="#虚基表指针在哪里" aria-hidden="true">#</a> 虚基表指针在哪里？</h4><p>虚基表指针存在于<mark>虚继承的派生类对象</mark>中；</p><h4 id="虚基类表的作用" tabindex="-1"><a class="header-anchor" href="#虚基类表的作用" aria-hidden="true">#</a> 虚基类表的作用</h4><p>虚基类表就是用来解决继承过程中，菱形继承的二义性和数据冗余的问题。</p><h4 id="虚基表指针和虚表指针对比" tabindex="-1"><a class="header-anchor" href="#虚基表指针和虚表指针对比" aria-hidden="true">#</a> 虚基表指针和虚表指针对比</h4><table><thead><tr><th></th><th>虚基表指针</th><th>虚表指针</th></tr></thead><tbody><tr><td>生成条件</td><td>有虚继承时产生</td><td>有虚函数时产生</td></tr><tr><td>指向</td><td>指向虚基表</td><td>指向虚表</td></tr><tr><td>指向内容</td><td>派生类对象中的基类成员对于该对象首地址的偏移量</td><td>类中所有虚函数的地址</td></tr><tr><td>存放位置</td><td>派生类中</td><td>基类中</td></tr><tr><td>作用</td><td>解决菱形继承时的二义性和数据冗余的问题</td><td>是多态的基础</td></tr></tbody></table><h2 id="顶层const和底层const" tabindex="-1"><a class="header-anchor" href="#顶层const和底层const" aria-hidden="true">#</a> 顶层const和底层const</h2><p>顶层const指的是修饰的变量本身是常量</p><p>底层const指的是修饰的变量所指向的变量是常量</p><p>被const修饰的常量是无法赋值给一个非const的变量，容易想到如果能赋值给一个非const变量，那么这个常量就能被修改了，但这个非const变量的值来源于const变量，显然不合理。</p><h2 id="数组名和指针-这里为指向数组首元素的指针-区别" tabindex="-1"><a class="header-anchor" href="#数组名和指针-这里为指向数组首元素的指针-区别" aria-hidden="true">#</a> 数组名和指针（这里为指向数组首元素的指针）区别？</h2><ul><li>二者均可通过增减偏移量来访问数组中的元素。</li><li>数组名不是真正意义上的指针，可以理解为常指针，所以数组名没有自增、自减等操作。</li><li><strong>当数组名当做形参传递给调用函数后，就失去了原有特性，退化成一般指针，多了自增、自减操作，但sizeof运算符不能再得到原数组的大小了。</strong></li></ul><h2 id="override和final" tabindex="-1"><a class="header-anchor" href="#override和final" aria-hidden="true">#</a> override和final</h2><h3 id="override" tabindex="-1"><a class="header-anchor" href="#override" aria-hidden="true">#</a> override</h3><p>当在父类中使用了虚函数（Java的普通函数就虚函数）时候，可能需要在某个子类中对这个虚函数进行重写，那么重写时最好加上override关键字。</p><p>如果不使用override，当你手一抖，将**foo()<strong>写成了</strong>f00()**会怎么样呢？结果是编译器并不会报错，因为它并不知道你的目的是重写虚函数，而是把它当成了新的函数。如果这个虚函数很重要的话，那就会对整个程序不利。所以，override的作用就出来了，它指定了子类的这个虚函数是重写的父类的，如果你名字不小心打错了的话，编译器是不会编译通过的。</p><h3 id="final" tabindex="-1"><a class="header-anchor" href="#final" aria-hidden="true">#</a> final</h3><p>当不希望某个类被继承，或不希望某个虚函数被重写，可以在类名和虚函数后添加final关键字，添加final关键字后被继承或重写，编译器会报错。Java的类想不被继承或者函数不被重写，就加个final即可。</p><h2 id="野指针和悬空指针" tabindex="-1"><a class="header-anchor" href="#野指针和悬空指针" aria-hidden="true">#</a> 野指针和悬空指针</h2><p>野指针：指针变量未及时初始化 =&gt; 定义指针变量及时初始化，要么置空。</p><p>悬空指针：指针free或delete之后没有及时置空 =&gt; 释放操作后立即置空。</p><h2 id="运行阶段类型识别dynamic-cast" tabindex="-1"><a class="header-anchor" href="#运行阶段类型识别dynamic-cast" aria-hidden="true">#</a> 运行阶段类型识别dynamic_cast</h2><p>运行阶段类型识别（RTTI RunTime Type Identification）为程序在运行阶段确定对象的类型，<strong>只适用于包含虚函数的类</strong>，RTTI的相关信息被保存在有声明虚函数的类的虚表中。</p><p>基类指针可以指向派生类对象，如何知道基类指针指向的是哪种派生类的对象呢？（想调用派生类中的非虚函数）。</p><p>dynamic_cast运算符用指向基类的指针来生成派生类的指针，它不能回答“指针指向的是什么类的对象”的问题，但能回答==“是否可以安全的将对象的地址赋给特定类的指针”==的问题。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>语法：派生类指针 = dynamic_cast&lt;派生类类型 *&gt;(基类指针);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果转换成功，dynamic_cast返回对象的地址，如果失败，返回nullptr。</p><p>注意：</p><ul><li><p>dynamic_cast只适用于包含<mark>虚函数</mark>的类，因为该关键字需要查虚表获取RTTI信息。</p></li><li><p>dynamic_cast可以将派生类指针转换为基类指针，这种画蛇添足的做法没有意义。</p></li><li><p>dynamic_cast可以用于引用，但是，没有与空指针对应的引用值，如果转换请求不正确，会出现bad_cast异常，但C++11已经放弃了异常处理。</p></li></ul><h2 id="重载、隐藏和重写-覆盖" tabindex="-1"><a class="header-anchor" href="#重载、隐藏和重写-覆盖" aria-hidden="true">#</a> 重载、隐藏和重写（覆盖）</h2><h3 id="重载" tabindex="-1"><a class="header-anchor" href="#重载" aria-hidden="true">#</a> 重载</h3><p>重载是指在同一范围定义中的同名成员函数才存在重载关系。主要特点是函数名相同，参数类型和数目有所不同，不能出现参数个数和类型均相同，仅仅依靠返回值不同来区分的函数。重载和函数成员是否是虚函数无关。</p><h3 id="隐藏" tabindex="-1"><a class="header-anchor" href="#隐藏" aria-hidden="true">#</a> 隐藏</h3><p>隐藏指的是某些情况下，派生类中的函数屏蔽了基类中的同名函数，包括以下情况：</p><ol><li>两个函数参数相同，但是基类函数不是虚函数。和重写的区别在于基类函数是否是虚函数。</li><li>两个函数参数不同，无论基类函数是不是虚函数，都会被隐藏。和重载的区别在于两个函数不在同一个类中。</li></ol><h3 id="重写-覆盖" tabindex="-1"><a class="header-anchor" href="#重写-覆盖" aria-hidden="true">#</a> 重写（覆盖）</h3><p>重写指的是在派生类中覆盖基类中的同名函数，<strong>重写就是重写函数体</strong>，<strong>要求基类函数必须是虚函数</strong>且：</p><ul><li>与基类的虚函数有相同的参数个数</li><li>与基类的虚函数有相同的参数类型</li><li>与基类的虚函数有相同的返回值类型</li></ul><p>重载与重写的区别：</p><ul><li>重写是父类和子类之间的垂直关系，重载是不同函数之间的水平关系</li><li>重写要求参数列表相同，重载则要求参数列表不同，返回值不要求</li><li>重写关系中，调用方法根据对象类型决定，重载根据调用时实参表与形参表的对应关系来选择函数体</li></ul><h2 id="浅拷贝和深拷贝的区别" tabindex="-1"><a class="header-anchor" href="#浅拷贝和深拷贝的区别" aria-hidden="true">#</a> 浅拷贝和深拷贝的区别</h2><p><strong>浅拷贝</strong></p><p>浅拷贝只是拷贝一个指针，并没有新开辟一个地址，拷贝的指针和原来的指针指向同一块地址，如果原来的指针所指向的资源释放了，那么再释放浅拷贝的指针的资源就会出现错误。</p><p><strong>深拷贝</strong></p><p>深拷贝不仅拷贝值，还开辟出一块新的空间用来存放新的值，即使原先的对象被析构掉，释放内存了也不会影响到深拷贝得到的值。在自己实现拷贝赋值的时候，如果有指针变量的话是需要自己实现深拷贝的。</p><p>从执行结果可以看出，浅拷贝在对象的拷贝创建时存在风险，即被拷贝的对象析构释放资源之后，拷贝对象析构时会再次释放一个已经释放的资源，深拷贝的结果是两个对象之间没有任何关系，各自成员地址不同。</p><h2 id="内联函数和宏定义的区别" tabindex="-1"><a class="header-anchor" href="#内联函数和宏定义的区别" aria-hidden="true">#</a> 内联函数和宏定义的区别</h2><ul><li>在使用时，宏只做简单字符串替换（编译前）。而内联函数可以进行参数类型检查（编译时），且具有返回值。</li><li>内联函数在编译时直接将函数代码嵌入到目标代码中，省去函数调用的开销来提高执行效率，并且进行参数类型检查，具有返回值，可以实现重载。</li><li>宏定义时要注意书写（参数要括起来）否则容易出现歧义，内联函数不会产生歧义</li><li>内联函数有类型检测、语法判断等功能，而宏没有</li></ul><p><strong>内联函数适用场景:</strong></p><ul><li>使用宏定义的地方都可以使用 inline 函数。</li><li>作为类成员接口函数来读写类的私有成员或者保护成员，会提高效率。</li></ul><h2 id="大端储存和小端储存" tabindex="-1"><a class="header-anchor" href="#大端储存和小端储存" aria-hidden="true">#</a> 大端储存和小端储存</h2><p>大端存储：字数据的高字节存储在低地址中</p><p>小端存储：字数据的低字节存储在低地址中</p><p>例如：32bit的数字0x12345678</p><p><strong>所以在Socket编程中，往往需要将操作系统所用的小端存储的IP地址转换为大端存储，这样才能进行网络传输</strong></p><p>小端模式中的存储方式为：</p><figure><img src="`+c+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>大端模式中的存储方式为：</p><figure><img src="'+o+`" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h3 id="判断大端储存和小端储存的程序代码" tabindex="-1"><a class="header-anchor" href="#判断大端储存和小端储存的程序代码" aria-hidden="true">#</a> 判断大端储存和小端储存的程序代码</h3><p><strong>方式一：使用强制类型转换</strong>-这种法子不错</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0x12345678</span><span class="token punctuation">;</span>
<span class="token comment">//由于int和char的长度不同，借助int型转换成char型，只会留下低地址的部分</span>
<span class="token comment">//而char只占1B，int在32位和64位编译器中占4B</span>
<span class="token keyword">char</span> c <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0x12</span><span class="token punctuation">)</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;big endian&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0x78</span><span class="token punctuation">)</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;little endian&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>方式二：巧用union联合体</strong></p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token comment">//union联合体的重叠式存储，endian联合体占用内存的空间为每个成员字节长度的最大值</span>
<span class="token keyword">union</span> endian
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> a<span class="token punctuation">;</span>
    <span class="token keyword">char</span> ch<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    endian value<span class="token punctuation">;</span>
    value<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">0x12345678</span><span class="token punctuation">;</span>
    <span class="token comment">//a和ch共用4字节的内存空间</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>value<span class="token punctuation">.</span>ch <span class="token operator">==</span> <span class="token number">0x12</span><span class="token punctuation">)</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;big endian&quot;</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>value<span class="token punctuation">.</span>ch <span class="token operator">==</span> <span class="token number">0x78</span><span class="token punctuation">)</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;little endian&quot;</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="volatile、mutable和explicit关键字的用法" tabindex="-1"><a class="header-anchor" href="#volatile、mutable和explicit关键字的用法" aria-hidden="true">#</a> volatile、mutable和explicit关键字的用法</h2><ol><li><strong>volatile</strong></li></ol><p>volatile 关键字是一种类型修饰符，<strong>用它声明的类型变量表示可以被某些编译器未知的因素更改</strong>，比如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。</p><p>当要求使用 volatile 声明的变量的值的时候，<strong>系统总是重新从它所在的内存读取数据</strong>，即使它前面的指令刚刚从该处读取过数据。</p><p><strong>volatile定义变量的值是易变的，每次用到这个变量的值的时候都要去重新读取这个变量的值，而不是读寄存器内的备份。多线程中被几个任务共享的变量需要定义为volatile类型。</strong></p><p><strong>volatile 指针</strong></p><p>volatile 指针和 const 修饰词类似，const 有常量指针和指针常量的说法，volatile 也有相应的概念</p><p>修饰由指针指向的对象、数据是 const 或 volatile 的：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> cpch<span class="token punctuation">;</span><span class="token keyword">volatile</span> <span class="token keyword">char</span><span class="token operator">*</span> vpch<span class="token punctuation">;</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>指针自身的值——一个代表地址的整数变量，是 const 或 volatile 的：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">char</span><span class="token operator">*</span> <span class="token keyword">const</span> pchc<span class="token punctuation">;</span><span class="token keyword">char</span><span class="token operator">*</span> <span class="token keyword">volatile</span> pchv<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>注意</p><ul><li>可以把一个非volatile int赋给volatile int，但是不能把非volatile对象赋给一个volatile对象。</li><li>除了基本类型外，对用户定义类型也可以用volatile类型进行修饰。</li><li>C++中一个有volatile标识符的类只能访问它接口的子集，一个由类的实现者控制的子集。用户只能用const_cast来获得对类型接口的完全访问。此外，volatile向const一样会从类传递到它的成员。</li></ul><p><strong>多线程下的volatile</strong></p><p>有些变量是用volatile关键字声明的。当两个线程都要用到某一个变量且该变量的值会被改变时，应该用volatile声明，**该关键字的作用是防止优化编译器把变量从内存装入CPU寄存器中。**如果变量被装入寄存器，那么两个线程有可能一个使用内存中的变量，一个使用寄存器中的变量，这会造成程序的错误执行。volatile的意思是让编译器每次操作该变量时一定要从内存中真正取出，而不是使用已经存在寄存器中的值。</p><ol start="2"><li><strong>mutable</strong></li></ol><p>mutable的中文意思是“可变的，易变的”，跟constant（既C++中的const）是反义词。在C++中，mutable也是为了突破const的限制而设置的。被mutable修饰的变量，将永远处于可变的状态，即使在一个const函数中。我们知道，如果类的成员函数不会改变对象的状态，那么这个成员函数一般会声明成const的。但是，有些时候，我们需要<strong>在const函数里面修改一些跟类状态无关的数据成员，那么这个函数就应该被mutable来修饰，并且放在函数后后面关键字位置</strong>。</p><p>样例</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">person</span>
<span class="token punctuation">{</span>
<span class="token keyword">int</span> m_A<span class="token punctuation">;</span>
<span class="token keyword">mutable</span> <span class="token keyword">int</span> m_B<span class="token punctuation">;</span><span class="token comment">//特殊变量 在常函数里值也可以被修改</span>
<span class="token keyword">public</span><span class="token operator">:</span>
     <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token comment">//在函数里不可修改this指针指向的值 常量指针</span>
     <span class="token punctuation">{</span>
        m_A<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span><span class="token comment">//错误  不可修改值，this已经被修饰为常量指针</span>
        m_B<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">;</span><span class="token comment">//正确</span>
     <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">person</span>
<span class="token punctuation">{</span>
<span class="token keyword">int</span> m_A<span class="token punctuation">;</span>
<span class="token keyword">mutable</span> <span class="token keyword">int</span> m_B<span class="token punctuation">;</span><span class="token comment">//特殊变量 在常函数里值也可以被修改</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token keyword">const</span> person p<span class="token punctuation">;</span><span class="token comment">//修饰常对象 不可修改类成员的值</span>
p<span class="token punctuation">.</span>m_A<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span><span class="token comment">//错误，被修饰了指针常量</span>
p<span class="token punctuation">.</span>m_B<span class="token operator">=</span><span class="token number">200</span><span class="token punctuation">;</span><span class="token comment">//正确，特殊变量，修饰了mutable</span>
<span class="token punctuation">}</span>
 
        @阿秀<span class="token operator">:</span> 代码已成功复制到剪贴板
    
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3"><li><strong>explicit</strong></li></ol><p>explicit关键字用来修饰类的构造函数，被修饰的构造函数的类，不能发生相应的隐式类型转换，只能以<strong>显示的方式进行类型转换</strong>，注意以下几点：</p><ul><li>explicit 关键字只能用于类内部的构造函数声明上</li><li>explicit 关键字作用于单个参数的构造函数</li><li>被explicit修饰的构造函数的类，不能发生相应的隐式类型转换</li></ul><h2 id="内联函数" tabindex="-1"><a class="header-anchor" href="#内联函数" aria-hidden="true">#</a> 内联函数</h2><p>以 inline <strong>修饰</strong>的函数叫做内联函数，<strong>编译时</strong>C++编译器会在<strong>调用内联函数的地方展开</strong>，没有函数压栈的开销，内联函数提升程序运行的效率。</p><h2 id="构造函数或者析构函数中可以调用虚函数吗" tabindex="-1"><a class="header-anchor" href="#构造函数或者析构函数中可以调用虚函数吗" aria-hidden="true">#</a> 构造函数或者析构函数中可以调用虚函数吗</h2><p>简要结论：</p><ul><li>从语法上讲，调用完全没有问题。</li><li>但是从效果上看，往往不能达到需要的目的，这个时候会根据所在的作用域来选择执行的函数，这样就和虚函数的目的矛盾了。</li></ul><blockquote><p>《Effective C++》的解释是： 派生类对象构造期间进入基类的构造函数时，对象类型变成了基类类型，而不是派生类类型。 同样，进入基类析构函数时，对象也是基类类型。</p></blockquote><h2 id="重载-、" tabindex="-1"><a class="header-anchor" href="#重载-、" aria-hidden="true">#</a> 重载++、--</h2><p>后置的++或--会在形参列表中加个(int)用来区分</p><p>++和--运算符的重载：</p><p>1、递增和递减一般是改变对象的状态，所以一般是重载为成员函数。</p><p>2、重载递增递减，一定要和指针的递增递减区分开。因为这里的重载操作的是对象，而不是指针(由于指针是内置类型，指针的递增递减是无法重载的)，所以一般情况的递增递减是操作对象内部的成员变量。</p><p>3、递增和递减分为前置和后置情况，a = ++b;(前置)， a = b++;(后置)。因为符号一样，所以给后置版本加一个int形参作为区分，这个形参是0，但是在函数体中是用不到的，只是为了区分前置后置。</p><h2 id="什么情况下编辑器自动生成默认的构造函数" tabindex="-1"><a class="header-anchor" href="#什么情况下编辑器自动生成默认的构造函数" aria-hidden="true">#</a> 什么情况下编辑器自动生成默认的构造函数？</h2>`,252),k={href:"https://so.csdn.net/so/search?q=%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&spm=1001.2101.3001.7020",target:"_blank",rel:"noopener noreferrer"},g={href:"https://so.csdn.net/so/search?q=%E7%BC%96%E8%AF%91%E5%99%A8&spm=1001.2101.3001.7020",target:"_blank",rel:"noopener noreferrer"},f=i('<p>正确的说法:</p><p>只有默认构造函数”被需要“的时候编译器才会生成默认构造函数。</p><h2 id="模板类和模板函数的区别是什么" tabindex="-1"><a class="header-anchor" href="#模板类和模板函数的区别是什么" aria-hidden="true">#</a> 模板类和模板函数的区别是什么？</h2><p>函数模板的实例化是由编译程序在处理函数调用时自动完成的，而类模板的实例化必须由程序员在程序中显式地指</p><p>定。即函数模板允许隐式调用和显式调用而类模板只能显示调用。在使用时类模板必须加<code>&lt;T&gt;</code>，而函数模板不必</p><h2 id="模板的实现可不可以不写在一个文件里面-为什么" tabindex="-1"><a class="header-anchor" href="#模板的实现可不可以不写在一个文件里面-为什么" aria-hidden="true">#</a> 模板的实现可不可以不写在一个文件里面？为什么？</h2><p>在C/C++中编译和链接过程是分离的，链接过程可以将各个由.cpp文件编译并汇编成的.o文件链接到一起，链接时候会由链接器寻找各个函数在其他.o文件中的定义。</p><p>而模板类或模板函数在进行编译的时候就要进行实例化，进行实例化的时候必须找到定义，这一步不能拖到链接过程。所以，模板类或模板函数的实现必须一起写到头文件中。</p><h2 id="联编" tabindex="-1"><a class="header-anchor" href="#联编" aria-hidden="true">#</a> 联编</h2><p>联编是指一个计算机程序自身彼此关联（使一个源程序经过编译、连接，成为一个可执行程序）的过程，在这个联编过程中，需要确定程序中的操作调用（函数调用）与执行该操作（函数）的代码段之间的映射关系，按照联编所进行的阶段不同，可分为静态联编和动态联编。</p><p>静态联编<br> 静态联编又称静态束定、早期联编、前期联编。</p><p>静态联编是指联编工作是在程序编译连接阶段进行的，静态联编又称早期联编，因为这种联编是在程序开始运行之前完成的。在程序编译阶段进行的这种联编又称静态束定，在编译时就解决了程序中的操作调用与执行该操作代码间的关系，确定这种关系又被称为束定，编译时束定又称为静态束定。</p><p>特点：</p><p>调用速度快，效率高。</p><p>动态联编<br> 动态联编又称动态关联、动态束定、后期联编、晚期联编。</p><p>动态联编是指编译程序在编译阶段并不能确切地知道将要调用的函数，只有在程序执行时才能确定将要调用的函数，为此要确切地知道将要调用的函数,要求联编工作在程序运行时进行，这种在程序运行时进行的联编工作被称为动态联编。C++规定：动态联编是在虚函数的支持下实现的。</p><p>动态联编必须包括以下方面：</p><p>1、成员函数必须声明为virtual</p><p>2、如果基类中声明了为虚函数，则派生类中不必再声明。</p><p>调用方式：</p><p>通过对象的指针或引用调用成员函数，或通过成员函数调用，反之就无法实现动态联编。</p><p>特点：</p><p>灵活，问题抽象性和问题的易维护性。</p><h2 id="排序" tabindex="-1"><a class="header-anchor" href="#排序" aria-hidden="true">#</a> 排序</h2><h3 id="插入排序" tabindex="-1"><a class="header-anchor" href="#插入排序" aria-hidden="true">#</a> 插入排序</h3><ul><li>直接插入</li><li>折半插入</li><li>希儿排序</li></ul><h3 id="选择排序" tabindex="-1"><a class="header-anchor" href="#选择排序" aria-hidden="true">#</a> 选择排序</h3><ul><li>简单选择</li><li>堆排</li></ul><h3 id="交换排序" tabindex="-1"><a class="header-anchor" href="#交换排序" aria-hidden="true">#</a> 交换排序</h3><ul><li>冒泡</li><li>快排</li></ul><h3 id="归并" tabindex="-1"><a class="header-anchor" href="#归并" aria-hidden="true">#</a> 归并</h3><h3 id="基数排序" tabindex="-1"><a class="header-anchor" href="#基数排序" aria-hidden="true">#</a> 基数排序</h3><h3 id="桶排序" tabindex="-1"><a class="header-anchor" href="#桶排序" aria-hidden="true">#</a> 桶排序</h3><h2 id="static的用法" tabindex="-1"><a class="header-anchor" href="#static的用法" aria-hidden="true">#</a> static的用法</h2><p>static是C++中的关键字之一，</p><p>在类外面，它有多种用法和作用，主要是隐藏、共享、持久化。</p><ol><li><p>持久化，用于指定变量、函数或类成员的存储区域为静态存储区域，这样这些变量、函数或类成员就可以在整个程序运行期间一直存在，不会因为作用域的结束而销毁。同时，静态变量和静态函数也只能在当前文件内被访问，无法被其他文件引用。</p></li><li><p>共享，用于限定类成员的作用域。static修饰的类成员属于类本身，而不是对象，因此它可以被所有对象共享。另外，由于静态成员不属于任何一个具体的对象，所以它不占用对象的内存空间。</p></li><li><p>隐藏，用于限制函数或变量的作用域。如果在函数或变量前面加上static关键字，则它们的作用域仅限于当前文件内，不会被其他文件访问到。</p></li></ol><p>总之，static关键字的作用主要是控制变量或函数的生命周期（持久化）和作用域（隐藏），以及限制类成员的访问权限（共享）。</p><p>在类内部，它有static成员变量和static成员函数。</p><ol><li><p>static成员变量：只与类关联，不与类的对象关联。定义时要分配空间，不能在类声明中初始化，必须在类定义体外部初始化，初始化时不需要标示为static；可以被非static成员函数任意访问。</p></li><li><p>static成员函数：不具有this指针，无法访问类对象的非static成员变量和非static成员函数；<strong>不能被声明为const、虚函数和volatile</strong>；可以被非static成员函数任意访问</p></li></ol>',40);function x(y,w){const e=l("ExternalLinkIcon");return p(),r("div",null,[h,a("p",null,[n("c++11以后引入两个关键字 "),a("a",v,[n("alignas (opens new window)"),s(e)]),n("与 "),a("a",m,[n("alignof (opens new window)"),s(e)]),n("。")]),b,a("p",null,[n("首先我们需要明确，在没有显示定义"),a("a",k,[n("构造函数"),s(e)]),n("的时候，编辑器不一定会自动生成默认的构造函数")]),a("p",null,[n("对c++初学者来说存在一个误区，如果类没有定义任何构造函数，"),a("a",g,[n("编译器"),s(e)]),n("会自动生成默认的构造函数。")]),f])}const q=t(u,[["render",x],["__file","Cpp.html.vue"]]);export{q as default};
