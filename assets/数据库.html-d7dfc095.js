import{_ as a,X as e,Y as n,a1 as h}from"./framework-3d5a2a18.js";const r={},d=h('<h2 id="_1nf、2nf、3nf、bcnf" tabindex="-1"><a class="header-anchor" href="#_1nf、2nf、3nf、bcnf" aria-hidden="true">#</a> 1NF、2NF、3NF、BCNF</h2><h3 id="部分函数依赖" tabindex="-1"><a class="header-anchor" href="#部分函数依赖" aria-hidden="true">#</a> 部分函数依赖</h3><p>X–&gt;Y，X&#39;是X的真子集，若满足X&#39;–&gt;Y，那么Y部分函数依赖于X，这就是部分函数依赖。</p><h3 id="完全函数依赖" tabindex="-1"><a class="header-anchor" href="#完全函数依赖" aria-hidden="true">#</a> 完全函数依赖</h3><p>X–&gt;Y，X&#39;是X的真子集，若满足X&#39;!–&gt;Y，那么Y完全函数依赖于X，这就是完全函数依赖。</p><h3 id="_1nf" tabindex="-1"><a class="header-anchor" href="#_1nf" aria-hidden="true">#</a> 1NF</h3><p>字段不可分，且不存在重复字段</p><h3 id="_2nf" tabindex="-1"><a class="header-anchor" href="#_2nf" aria-hidden="true">#</a> 2NF</h3><p>有主键，且非主键字段完全函数依赖于主键，不能部分函数依赖于主键</p><h3 id="_3nf" tabindex="-1"><a class="header-anchor" href="#_3nf" aria-hidden="true">#</a> 3NF</h3><p>在2NF基础上，消除非主键函数依赖于非主键</p><h3 id="bcnf" tabindex="-1"><a class="header-anchor" href="#bcnf" aria-hidden="true">#</a> BCNF</h3><p>在3NF基础上，消除任意键部分函数依赖于主键</p><h2 id="mysql常见的存储引擎innodb、myisam的区别-适用场景分别是" tabindex="-1"><a class="header-anchor" href="#mysql常见的存储引擎innodb、myisam的区别-适用场景分别是" aria-hidden="true">#</a> MySQL常见的存储引擎InnoDB、MyISAM的区别？适用场景分别是？</h2><p>1）事务：MyISAM不支持，InnoDB支持</p><p>2）锁级别： MyISAM 表级锁，InnoDB 行级锁及外键约束</p><p>3）MyISAM存储表的总行数；InnoDB不存储总行数；</p><p>4）MyISAM采用非聚集索引，B+树叶子存储指向数据文件的指针。InnoDB主键索引采用聚集索引，B+树叶子存储数据</p><p><strong>适用场景</strong>：</p><p>MyISAM适合： 插入不频繁，查询非常频繁，如果执行大量的SELECT，MyISAM是更好的选择， 没有事务。</p><p>InnoDB适合： 可靠性要求比较高，或者要求事务； 表更新和查询都相当的频繁， 大量的INSERT或UPDATE</p><h2 id="条件子句" tabindex="-1"><a class="header-anchor" href="#条件子句" aria-hidden="true">#</a> 条件子句</h2><p>「where」、「on」和「having」都是用于数据库查询语句中的条件子句。</p><p>「Where」子句主要用于从表中选择行记录，它可以筛选出符合指定条件的行。它通常出现在SELECT、UPDATE和DELETE语句中，用于限制返回结果的行数。</p><p>「On」子句则用于连接两个或多个表，它通常出现在JOIN语句中，用于指定连接条件。在多表查询中，「on」子句用于指定关联条件，将多个表中的数据进行匹配，获得需要的数据集合。</p><p>「Having」子句用于对分组后的数据进行筛选，它只能与GROUP BY一起使用。它允许我们对分组后的数据进行聚合运算，并通过指定条件来过滤分组结果集。</p><p>简单来说，「where」子句用于行级别的筛选，「on」子句用于连接多个表，而「having」子句用于分组后的筛选。</p>',27),i=[d];function t(p,c){return e(),n("div",null,i)}const o=a(r,[["render",t],["__file","数据库.html.vue"]]);export{o as default};
